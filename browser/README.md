# 浏览器

# 进程和线程

> 进程是 cpu 资源分配的最小单位； 线程是 cpu 调度的最小单位；

## 进程和线程的关系

1. 通俗来讲，每一个执行中的程序就可以称之为进程，而一个进程由多个线程组成；
2. 一个进程中任意一个线程出错，就会导致整个进程出错；
3. 一个进程中的所有线程共享进程中的数据；
4. 不同进程之间的内容相互隔离；
5. 关闭进程时，进程中的所有线程也会被关闭；

## 多进程浏览器的优势

1. 我们打开的每个 tab 页，即使卡顿、崩溃，也只是那一个进程会受到影响，其他进程不会受到影响；
2. 现在很多 cpu 都是多核的，而多进程可以完美的发挥 cpu 的优势；
3. 浏览器中还有插件进程，同时也保证了不同插件发生崩溃时不会影响到浏览器的使用；

# 浏览器内核

> 浏览器内核是属于多进程浏览器的其中一个进程，也被称为渲染进程，它拥有多个线程

（1）主流浏览器的内核

- chrome 使用 blink 内核，之前使用的是由 Chromium 内核（fork 自 webkit）；
- safari 使用的是 webkit 内核，是 webkit 的鼻祖；
- firefox 使用的是 Gecko 内核；
- IE/Edge 使用的是 Trident 内核；
- Opera 使用的是 blink 内核（因为是和谷歌一起研发的）；

（2）浏览器内核中的线程
渲染进程中一般由以下几种线程组成：

- GUI 渲染线程
- JavaScript 引擎线程
- 定时器触发线程
- 事件触发线程
- 异步 http 请求线程

# JS 是单线程还是多线程

js 是`单线程`的，原因是因为 js 最初的使用场景最多的就是`与用户的交互`，这就离不开 `dom 的操作` ，只有单线程，才能保证同一时间，用户只能操作一种功能，如果是多线程，就会造成很多问题。

# Web Worker 是什么？

> Web Worker 使得在一个独立于 Web 应用程序主执行线程的后台线程中运行脚本操作成为可能。这样做的好处是可以在独立线程中执行费时的处理任务，使主线程（通常是 UI 线程）的运行不会被阻塞/放慢。

- Web Worker 是浏览器为 JavaScript 创建的一个多线程环境，但它并不代表 js 是多线程的。

- 在 Web Worker 中是不能操作 dom 的，这是因为我们通过 new Worker()创建一个 Worker 时，虽然浏览器单独开辟出来了一个新的线程，但是当前线程只是帮助我们运行一些复杂、耗时的任务，它还是受主线程控制的，因此，严格意义上来说，js 是单线程这一点，从未改变过。

# 浏览器缓存机制

## 强缓存

浏览器首先使用的是强缓存

使用强缓存的时候不会发送 HTTP 请求，直接从缓存中读取资源，返回状态码为 200，size 显示为 from disk cache 或 from memory cache。

强缓存可以通过设置两种 HTTP Header 实现：`Expires 和 Cache-Control`

### Expires(HTTP/1.0)

Expires 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:

```js
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在 2019 年 11 月 22 号 8 点 41 分过期，过期了就得向服务端发请求。

这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是`服务器的时间和浏览器的时间可能并不一致`，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的 HTTP1.1 版本中被抛弃了。

### Cache-Control(HTTP/1.1)

在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。

Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：

```js
cache-control: public, max-age=31536000
```

## 协商缓存

强缓存失效之后，就进入了协商缓存阶段

浏览器在请求头中携带缓存标识，服务器根据缓存标识决定是否使用缓存，协商缓存生效则返回 304 和 Not Modified，失效则返回 200 和请求结果

协商缓存可以可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag

Last-Modified 和 If-Modified-Since
浏览器第一次访问资源时，response header 携带 Last-Modified（资源在服务器上的最后修改时间，最小单位 s），浏览器接收后缓存，下一次请求这个资源时 request header 携带 If-Modified-Since，如果修改时间没有变化，就使用缓存，返回 304，否则返回新资源和 200

```js
Last-Modified: Tue, 30 Mar 2021 03:30:52 GMT
```

Last-Modified 存在一些弊端

如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
ETag 和 If-None-Match
Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。

如果服务器发现 ETag 匹配不上，那么会返回 200 和新的资源（当然也包括了新的 ETag）发给客户端；

如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。

---

看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？

`对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。`

## 不使用缓存资源

**1. meta 缓存头设置为禁止缓存**

在 html 的 head 标签中加入下面内容，就可以禁止浏览器读取缓存

```html
<meta
  http-equiv="Cache-Control"
  content="no-cache, no-store, must-revalidate"
/>
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
```

Cache-Control 作用于 HTTP1.1 Pragma 作用于 HTTP1.0 Expires 作用于 proxies

但这样浏览器在资源没修改的时候也不能加载缓存，十分影响体验

**2. js、css 加上版本号**

当请求 js、css 的时候，给他们最后加上版本号，浏览器发现版本高了，就自然而然不会读取低版本的缓存了 版本号并不需要改变文件名，只需要在调用 js、css 的时候在最末尾加上?v=1.0 即可，比如

```js
custom.css?v=1.0
main.js?v=2.0
```

# js 文件、css 文件、html、图片资源之间的阻塞关系

- CSS 的解析和 HTML 的解析没有阻塞关系，因为二者在不同的线程完成，CSS 的解析在预解析线程，HTML 的解析在主线程；
- CSS 的解析会阻塞 HTML 的渲染，因为 HTML 的渲染需要 CSS 样式，如果 CSS 没有解析完毕，HTML 无法完成渲染；
- 不带 async 或者 defer 的 script 标签会阻塞 HTML 的解析，并且会等待执行完毕之后才会继续解析 HTML；
- 带 async 的 script 标签在下载时不会影响 HTML 的解析，因为是在不同的线程进行下载，但是下载完毕之后会立即执行，执行会阻塞 HTML 的解析；
- 带 defer 的 script 标签，不会影响 HTML 的解析，因为它在不同的线程进行下载，并且它会等待 HTML 解析完毕再进行执行；
- CSS 的解析和 js 的下载不会有任何阻塞关系，因为它们在不同的线程，但是会影响 js 的执行，因为 js 可能会操作 dom 修改 css，所以说必须等待 css 加载完毕，才能继续执行 js；
- 图片资源的加载，不会和任何产生冲突，因为它会在其它线程进行异步下载；

# CSS 为什么最好要放在头部

首先 `CSS 不会阻塞 HTML 的解析`，所以放头部和尾部没太大影响，但是 `CSS 会阻塞 HTML 的渲染`，如果把 CSS 放在尾部，HTML 解析完毕了，过了一会 CSS 又解析完毕了，浏览器又要根据 CSSOM 树重新计算 HTML 节点的样式，重新进行布局，可能会造成回流等现象。

# js 文件为什么放到尾部比较好

因为 `js 文件会阻塞 HTML 的解析`，如果放在头部，js 文件过大时，会导致 HTML 解析长时间无法完成，DOM 树无法构建，页面无法渲染，造成长时间白屏的现象，影响用户体验

# 同源策略限制了哪些行为

- 不能发送网络请求；
- 不能获取或操作 dom；
- 不能获取本地存储，如 cookie、storage、IndexedDB 等；

# 如何解决跨域

- 跨域资源共享（CORS）
- jsonp
- nginx 反向代理
- postMessage 跨域
- 设置代理服务器

# Cookie 和 Session 的区别

- 二者都是为了解决 HTTP 的无状态而产生的；
- Cookie 是保存在客户端的，而 Session 是保存在服务端的；

# 浏览器渲染之——回流和重绘

**（1）什么是回流**

回流又称重排，它指的是我们修改或者访问了一些 HTML 元素的几何信息，比如宽高等，当我们操作了这些之后，浏览器就需要重新计算每一个元素的布局位置等，重新生成布局树，然后进行分层分块光栅化等一系列操作，频繁的操作会引起页面的卡顿，影响页面性能。

**（2）什么是重绘**

重绘指的是没有修改元素的几何信息，只是修改了外观，例如背景颜色、字体颜色等，这些操作不会引起浏览器重新计算布局，但是需要浏览器重新进行绘制操作，相对于回流来说，性能会稍好一些。

**（3）如何减少回流/重绘的产生**

为了我们的页面能拥有更好的性能，通常我们会尽量减少回流和重绘的发生，可以通过以下方式：

- 操作 dom 修改样式时，尽量修改元素的 class 代替修改元素的 style，将多个 style 在一个 class 中完成；
- 将一些复杂的动画效果运用到 position 为 fixed 或者 absolute 的元素上，这些元素会脱离文档流，不会影响其他元素的布局；
- 对 DOM 进行离线处理，在对 DOM 进行多次影响布局的操作时，可以先将 DOM 的 display 设置为 none，然后处理完毕再进行展示，就会在一次回流中处理完毕；
- 利用 GPU 加速，也就是多采用 transform 代替 left、right 等操作，因为 transform 是在浏览器渲染的最后一步交由 GPU 硬件来进行绘制的，性能会更好，也不会引起回流重绘，此外 opacity、filters 也是；

# 事件传播阶段（事件模型）

事件传播分为三个阶段，顺序依次是`捕获 -> 目标 -> 冒泡`：

（1）捕获阶段：从 window 开始，向事件的触发处传播，但是此时不会触发事件，因此到达目标父级；

（2）目标阶段：事件到达目标元素，触发目标事件；

（3）冒泡阶段：然后从目标开始，向上传播，遇到注册的冒泡事件会触发；

- 事件冒泡
  在事件传播的过程中，子元素的事件会依次向父级传播，由内向外传播，就称之为事件冒泡；

  这就会造成，我们明明想触发父元素的事件，但是子元素的事件也同时被触发；

- 事件捕获
  事件传播的过程中，父元素的事件会向子元素传播，由外向内传播，就称之为事件捕获；

- 如何取消事件冒泡
  IE 浏览器可以在处理事件回调函数中添加 `e.cancelBubble = true` 来取消事件冒泡；

  符合 W3C 标准的浏览器可以在处理事件回调函数中添加 `e.stopPropagation()`来取消事件冒泡；

- 如何取消默认事件
  某些标签拥有默认事件，比如 a 标签、form 表单等，如果我们想阻止这些元素的默认事件，可以通过以下方式进行解决：

  正常的浏览器可以通过 `e.preventDefault()`；

  IE 则需要通过 `e.returnValue = false`；

# V8 引擎

## V8 引擎是什么

- V8 是由 C++编写的 JavaScript 和 WebAssembly 引擎，也正是有了 V8，chrome 浏览器才会在众多浏览器中脱颖而出；

- V8 可以独立运行，也可以嵌入到任何 C++应用程序中，Node.js 就是基于 V8 引擎的；

> V8 引擎对 js 代码的处理流程大概如下：

- V8 引擎解析 JavaScript 代码时，首先会将代码通过 Parser 进行词法分析和语法分析解析为 `AST 抽象语法树`(一个查看 AST 语法树的网站)，vue 中的 template 以及 babel 都使用了 AST 抽象语法树；

- 然后会通过 Ignition 是一个解释器，将 AST 抽象语法树转化为`字节码`，同时会帮助 Turbofan 收集一些优化所需要的信息（比如函数的参数类型信息，函数的调用次数等）；

- 之后将`字节码转化为机器码`被计算机识别并执行，（为什么不直接转化为机器可以识别的机器码呢？因为不同的机器拥有不同的 CPU，不同架构的 CPU 所支持的机器指令不同，因此不能直接转化为机器指令，而是逐步转换）；

- Turbofan 是一个编译器，一些高频的代码，它会对其进行标记（hot），把这些代码的机器指令保存下来，再次执行时，无需转换字节码，可直接执行机器指令，这也是 V8 引擎快速的原因之一；

- 在执行 Turbofan 中保存的函数时，如果函数参数类型发生改变，函数的执行流程可能有所不同，因此会通过 deoptimization 进行反向优化, 把机器码重新转化成字节码再次进行编译运行；

## JavaScript 中的内存管理

> 在 JavaScript 中，如果是基本数据类型，V8 会帮助我们在栈空间分配内存；
> 如果是复杂数据类型，会帮助我们在堆空间分配内存，并将对该变量的引用指向该块堆空间，但是该块空间的内存地址，存在栈空间中；
> 访问一个对象时，会先去栈空间找它的引用地址，然后再去堆空间找到数据；

## 垃圾回收

> 因为内存空间大小是有限的，因此一些数据如果在不使用的时候不进行回收或销毁，就会一直占用内存，如果数据太多，就会出现栈溢出的报错，因此，当一些数据不再需要时，我们应对其进行回收，垃圾回收器（Garbage Collection）也称作 GC。

### 常见的垃圾回收算法

- `引用计数`：当一个变量被引用时，内部就会记录它的引用次数，当引用次数为 0 时，就会被垃圾回收器回收掉；它的弊端也很明显，如果两个变量相互引用，那么计数就永远不会是 0，内存就永远不会被回收，造成`内存泄漏`问题；
- `标记清除`：设置一个根对象（Root Object），垃圾回收器会定期从根对象开始查找，如果某些对象`没有被引用到`，就会把这些对象进行垃圾回收，该算法可以`很好的解决循环引用问题`，大多数 js 引擎采用该方法，而 V8 为了更好的优化，还搭配了一些其他算法使用

### V8 引擎中的垃圾回收

> 栈内存的回收

- 在 js 中，由于 js 是单线程的，每次执行函数的过程就是一个压栈的过程，在 V8 中，每次执行一个函数时，就会有一个 ESP 指针指向当前正在执行的上下文，当执行完毕时，指针就会向下移动，上一个执行上下文的内存就会被回收，局部活动对象也就会随之销毁。

> 堆内存的回收

- V8 引擎对于堆内存中的变量，将它们分为了两种，分别是新生代和老生代；
- 新生代指的就是那些存活时间比较短的对象，这个区域大小通常大小在 1~8M 左右；
- 老生代指的就是那些存活时间比较长的对象，这个区域容量相对比较大；
- V8 为新生代和老生代又使用了了两个主要的垃圾回收器，分别是副垃圾回收器，负责新生代区域的垃圾回收，以及主垃圾回收器，负责老生代区域的垃圾回收

# 浏览器的安全性问题

## XSS 攻击

XSS 攻击就是跨站脚本攻击，指那些通过在 HTML 文档中嵌入 js 脚本的方式，从而获取到用户的私密信息的操作，它主要有三种，分别是存储型、反射型、文档型。

- 存储型：一般指一些输入框没有做 js 脚本的校验，导致黑客输入了一些恶意脚本，然后上传至服务器，然后客户端拿到这些数据又进行了执行；
- 反射型：一般指将恶意脚本作为网络请求的参数发送给服务器，服务器解析之后拼接到 HTML 文档中发送给客户端，客户端进行执行了这些恶意脚本；
- DOM-based 型：比如一些由用户手动输入然后生成 DOM 的网站，攻击者将恶意脚本注入到页面中，用户输入内容时，恶意脚本篡改内容，最终执行了恶意脚本，达到了攻击的效果。

> 如何防止 XSS 攻击

- 我们可以通过严格校验用户输入内容，过滤一些可能发生风险的输入内容，对一些有特殊含义的字符进行转义；
- 利用 HttpOnly，不允许通过浏览器访问 cooike，以阻止 XSS 攻击窃取 cookie 中的敏感信息；
- 使用 CSP（浏览器安全策略）：只允许当前页面加载指定的外部资源，可以通过设置 http header 中的 Content-Security-Policy 或者 meta 标签中的 http-equiv 属性。

## CSRF

CSRF 就是跨站请求伪造，黑客诱导用户点击链接进入第三方站点，然后通过用户的 cookie 信息发起而已请求；

> 如何防止 CSRF 攻击

- 设置 samesite：通过设置 cookie 的 samesite 属性，阻止向第三方站点携带 cookie 信息；
- 服务端验证额外信息：比如可以给客户端 token，然后每次发起请求时让客户端携带 token；
- 阻止第三方页面发起请求：可以让服务端阻止第三方网站请求接口；

## 点击劫持

点击劫持是一种视觉欺骗手段，攻击者将被攻击者的网站通过 iframe 嵌入到自己的网页中，并且将 iframe 设置透明，然后放出一个按钮诱导用户点击；

> 如何预防点击劫持

X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
该响应头有三个值可选，分别是

- DENY，表示页面不允许通过 iframe 的方式展示
- SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
- ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

## SQL 注入

SQL 注入就是利用前端输入框校验漏洞以及后端 SQL 语句漏洞达到攻击目的，比如攻击者可以在输入框输入 SQL 命令，然后发送给服务端，服务端将 SQL 命令作为前端参数进行解析执行，可能会执行一些非自己意愿的 SQL 语句。

> 如何预防 SQL 注入

- 前端严格对输入框内容进行校验，将一些特殊含义的字符进行过滤；
- 服务端对前端参数也要严格进行校验，防止一些非法参数的混入；
